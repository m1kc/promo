# YepScript

Язык общего назначения. Сознательно лишён адресной арифметики и беззнаковых типов данных - в ряде случаев он будет менее эффективен, чем C++, но лучше, чем JS в VM.


## Основные идеи

* За основу взят CoffeeScript.
* Компилируется в нативный код через LLVM.
* Слабая типизация (но более сильная, чем в JS: не всё приводится ко всему).
* Опциональная строгая типизация (с ней код будет оптимальнее).
* Перегрузка операторов.
* Асинхронное I/O.
* Множественное присваивание.


## Типы данных


### Boolean

Да.


### Number

Число произвольной вместимости. Внутри бывает Integer и Float, при необходимости конвертируется из одного в другое. Умеет всю обычную арифметику. Приводится к Boolean по правилу: если 0, то false, иначе true.


### Array

Массив чего угодно. Сложение означает конкатенацию. Может быть типизированным, тогда элемент не того типа добавить не получится.


### String

Строка. При сложении с большинством типов тоже приводит их к строке (но не массивы: `[2, 4] + 'string' == [2, 4, 'string']`). Можно умножать: если умножить `жаба` на 2, получится `жабажаба`.


## Hello, world

```coffeescript
main = (String[] args) ->
	console.log 'Hello, world!'
```

Если `main` не объявлена, просто исполняем всё подряд:

```coffeescript
console.log 'Hello, world!'
```

Если `main` возвращает строку, она выводится на экран:

```coffeescript
'Hello, world!'
```

Если число - это код возврата. Если что-нибудь ещё - игнорируется.

Функция `main` получает управление при условии, что файл исполняется (а не подключается через `require`). Инструкции вне `main` исполняются в любом случае до передачи ей управления. Получается как в питоне - один и тот же файл может быть и исполняемым, и библиотекой - но более изящно.


## Интерполяция

```coffeescript
console.log "2+2 = #{2+2}"  # 2+2 = 4
```

Но можно и лучше:

```coffeescript
console.log "#{{2+2}}"    # 2+2 = 4
console.log "#{{2 + 2}}"  # 2 + 2 = 4
```


## Передача по ссылке и по значению

По умолчанию числа, булеаны передаются по значению, а массивы и объекты - по ссылке. Но можно задать явно.

Если переменная куда-нибудь передаётся по ссылке, она хранится в куче. Если нет - на стеке или в регистре.

### По ссылке

```coffeescript
addOne = (Integer& x) ->
	x++

z = 5
console.log z  # 5
addOne z
console.log z  # 6
```

### По значению

```coffeescript
addOne = (Integer% x) ->
	x++

z = 5
console.log z  # 5
addOne z
console.log z  # 5
```


## Строгая типизация

```coffeescript
plusOne = (x) ->
	x + 1

console.log plusOne(5)  # 6
```

Если у функции явно задан тип аргумента, он будет проверен в рантайме.

```coffeescript
plusOne = (Integer x) ->
	x + 1

z = getNumberFromUser()
console.log z  # 5
console.log plusOne(z)  # 6
console.log plusOne('strawberry')  # TypeError
```

А если он известен во время компиляции, то и проверка будет во время компиляции, и код будет более оптимальным.

```coffeescript
plusOne = (Integer x) ->
	x + 1

Integer z = 5
console.log plusOne(z)  # Тип переменной z известен заранее
console.log plusOne(7)  # Тип константы известен заранее
console.log plusOne(2+2)  # Тип константного выражения легко вывести
console.log plusOne('well')  # Не скомпилируется
```
